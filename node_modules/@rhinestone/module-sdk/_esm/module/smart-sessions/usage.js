import { encodePacked, hashTypedData, encodeAbiParameters, encodeFunctionData, keccak256, slice, decodeAbiParameters, } from 'viem';
import { abi, encodeEnableSessionSignatureAbi } from './abi.js';
import { SMART_SESSIONS_ADDRESS } from './constants.js';
import { SmartSessionMode, } from './types.js';
import { LibZip } from 'solady';
export const getPermissionId = ({ session }) => {
    return keccak256(encodeAbiParameters([
        {
            type: 'address',
            name: 'sessionValidator',
        },
        {
            type: 'bytes',
            name: 'sessionValidatorInitData',
        },
        {
            type: 'bytes32',
            name: 'salt',
        },
    ], [
        session.sessionValidator,
        session.sessionValidatorInitData,
        session.salt,
    ]));
};
export const getActionId = async ({ target, selector, }) => {
    return keccak256(encodePacked(['address', 'bytes4'], [target, selector]));
};
export const getSessionNonce = async ({ client, account, permissionId, }) => {
    return (await client.readContract({
        address: SMART_SESSIONS_ADDRESS,
        abi,
        functionName: 'getNonce',
        args: [permissionId, account.address],
    }));
};
export const isSessionEnabled = async ({ client, account, permissionId, }) => {
    return (await client.readContract({
        address: SMART_SESSIONS_ADDRESS,
        abi,
        functionName: 'isPermissionEnabled',
        args: [permissionId, account.address],
    }));
};
export const getSessionDigest = async ({ client, account, session, permissionId, mode, }) => {
    return (await client.readContract({
        address: SMART_SESSIONS_ADDRESS,
        abi,
        functionName: 'getSessionDigest',
        args: [permissionId, account.address, session, Number(mode)],
    }));
};
export const encodeSmartSessionSignature = ({ mode, permissionId, signature, enableSessionData, }) => {
    switch (mode) {
        case SmartSessionMode.USE:
            return encodePacked(['bytes1', 'bytes32', 'bytes'], [
                mode,
                permissionId,
                LibZip.flzCompress(encodeAbiParameters([
                    {
                        type: 'bytes',
                    },
                ], [signature])),
            ]);
        case SmartSessionMode.ENABLE:
        case SmartSessionMode.UNSAFE_ENABLE:
            if (!enableSessionData) {
                throw new Error('enableSession is required for ENABLE mode');
            }
            return encodePacked(['bytes1', 'bytes'], [
                mode,
                LibZip.flzCompress(encodeEnableSessionSignature({ enableSessionData, signature })),
            ]);
        default:
            throw new Error(`Unknown mode ${mode}`);
    }
};
export const encodeUseOrEnableSmartSessionSignature = async ({ account, client, permissionId, signature, enableSessionData, }) => {
    const sessionEnabled = await isSessionEnabled({
        account,
        client,
        permissionId,
    });
    return sessionEnabled
        ? encodePacked(['bytes1', 'bytes32', 'bytes'], [
            SmartSessionMode.USE,
            permissionId,
            LibZip.flzCompress(encodeAbiParameters([
                {
                    type: 'bytes',
                },
            ], [signature])),
        ])
        : encodePacked(['bytes1', 'bytes'], [
            SmartSessionMode.ENABLE,
            LibZip.flzCompress(encodeEnableSessionSignature({ enableSessionData, signature })),
        ]);
};
export const decodeSmartSessionSignature = ({ signature, account, }) => {
    const mode = slice(signature, 0, 1);
    let permissionId;
    let compressedData;
    let data;
    switch (mode) {
        case SmartSessionMode.USE:
            permissionId = slice(signature, 1, 33);
            compressedData = slice(signature, 33);
            data = LibZip.flzDecompress(compressedData);
            const decodedSignature = decodeAbiParameters([
                {
                    type: 'bytes',
                },
            ], data)[0];
            return {
                mode,
                permissionId,
                signature: decodedSignature,
            };
        case SmartSessionMode.ENABLE:
        case SmartSessionMode.UNSAFE_ENABLE:
            compressedData = slice(signature, 1);
            data = LibZip.flzDecompress(compressedData);
            if (!account) {
                throw new Error('account is required for ENABLE mode decoding');
            }
            const decodedData = decodeAbiParameters(encodeEnableSessionSignatureAbi, data);
            const enableSession = decodedData[0];
            const permissionEnableSigSlice = account.type === 'kernel' ? 1 : 0;
            if (account.type === 'kernel' &&
                !enableSession.permissionEnableSig.startsWith('0x01')) {
                throw new Error('Invalid permissionEnableSig for kernel account');
            }
            const permissionEnableSig = slice(enableSession.permissionEnableSig, 20 + permissionEnableSigSlice);
            const validator = slice(enableSession.permissionEnableSig, 0 + permissionEnableSigSlice, 20 + permissionEnableSigSlice);
            return {
                mode: mode,
                permissionId: keccak256(encodeAbiParameters([
                    {
                        type: 'address',
                        name: 'sessionValidator',
                    },
                    {
                        type: 'bytes',
                        name: 'sessionValidatorInitData',
                    },
                    {
                        type: 'bytes32',
                        name: 'salt',
                    },
                ], [
                    enableSession.sessionToEnable.sessionValidator,
                    enableSession.sessionToEnable.sessionValidatorInitData,
                    enableSession.sessionToEnable.salt,
                ])),
                signature: decodedData[1],
                enableSessionData: {
                    enableSession: {
                        chainDigestIndex: enableSession.chainDigestIndex,
                        hashesAndChainIds: enableSession.hashesAndChainIds,
                        sessionToEnable: enableSession.sessionToEnable,
                        permissionEnableSig: permissionEnableSig,
                    },
                    validator: validator,
                    accountType: account.type,
                },
            };
        default:
            throw new Error(`Unknown mode ${mode}`);
    }
};
export const hashChainSessions = (chainSessions) => {
    return hashTypedData({
        domain: {
            name: 'SmartSession',
            version: '1',
        },
        types: {
            PolicyData: [
                { name: 'policy', type: 'address' },
                { name: 'initData', type: 'bytes' },
            ],
            ActionData: [
                { name: 'actionTargetSelector', type: 'bytes4' },
                { name: 'actionTarget', type: 'address' },
                { name: 'actionPolicies', type: 'PolicyData[]' },
            ],
            ERC7739Data: [
                { name: 'allowedERC7739Content', type: 'string[]' },
                { name: 'erc1271Policies', type: 'PolicyData[]' },
            ],
            SessionEIP712: [
                { name: 'account', type: 'address' },
                { name: 'smartSession', type: 'address' },
                { name: 'mode', type: 'uint8' },
                { name: 'sessionValidator', type: 'address' },
                { name: 'salt', type: 'bytes32' },
                { name: 'sessionValidatorInitData', type: 'bytes' },
                { name: 'userOpPolicies', type: 'PolicyData[]' },
                { name: 'erc7739Policies', type: 'ERC7739Data' },
                { name: 'actions', type: 'ActionData[]' },
                { name: 'nonce', type: 'uint256' },
            ],
            ChainSessionEIP712: [
                { name: 'chainId', type: 'uint64' },
                { name: 'session', type: 'SessionEIP712' },
            ],
            MultiChainSessionEIP712: [
                { name: 'sessionsAndChainIds', type: 'ChainSessionEIP712[]' },
            ],
        },
        primaryType: 'MultiChainSessionEIP712',
        message: {
            sessionsAndChainIds: chainSessions,
        },
    });
};
const encodeEnableSessionSignature = ({ enableSessionData, signature, }) => {
    return encodeAbiParameters(encodeEnableSessionSignatureAbi, [
        {
            chainDigestIndex: enableSessionData.enableSession.chainDigestIndex,
            hashesAndChainIds: enableSessionData.enableSession.hashesAndChainIds,
            sessionToEnable: enableSessionData.enableSession.sessionToEnable,
            permissionEnableSig: formatPermissionEnableSig({
                signature: enableSessionData.enableSession.permissionEnableSig,
                validator: enableSessionData.validator,
                accountType: enableSessionData.accountType,
            }),
        },
        signature,
    ]);
};
export const formatPermissionEnableSig = ({ signature, validator, accountType, }) => {
    switch (accountType) {
        case 'erc7579-implementation':
        case 'nexus':
        case 'safe':
            return encodePacked(['address', 'bytes'], [validator, signature]);
        case 'kernel':
            return encodePacked(['bytes1', 'address', 'bytes'], ['0x01', validator, signature]);
        default:
            throw new Error(`Unsupported account type: ${accountType}`);
    }
};
export const getEnableSessionsAction = ({ sessions, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'enableSessions',
        args: [sessions],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getRemoveSessionAction = ({ permissionId, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'removeSession',
        args: [permissionId],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getEnableUserOpPoliciesAction = ({ permissionId, userOpPolicies, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'enableUserOpPolicies',
        args: [permissionId, userOpPolicies],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getDisableUserOpPoliciesAction = ({ permissionId, userOpPolicies, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'disableUserOpPolicies',
        args: [permissionId, userOpPolicies],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getEnableERC1271PoliciesAction = ({ permissionId, erc1271Policies, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'enableERC1271Policies',
        args: [permissionId, erc1271Policies],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getDisableERC1271PoliciesAction = ({ permissionId, policies, contents, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'disableERC1271Policies',
        args: [permissionId, policies, contents],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getEnableActionPoliciesAction = ({ permissionId, actionPolicies, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'enableActionPolicies',
        args: [permissionId, actionPolicies],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getDisableActionPoliciesAction = ({ permissionId, actionId, policies, }) => {
    const data = encodeFunctionData({
        abi,
        functionName: 'disableActionPolicies',
        args: [permissionId, actionId, policies],
    });
    return {
        to: SMART_SESSIONS_ADDRESS,
        target: SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getEnableSessionDetails = async ({ sessions, sessionIndex, enableMode, account, clients, }) => {
    const chainDigests = [];
    const chainSessions = [];
    for (const session of sessions) {
        const permissionId = getPermissionId({
            session,
        });
        const client = clients.find((c) => BigInt(c.chain?.id ?? 0) === session.chainId);
        if (!client) {
            throw new Error(`Client not found for chainId ${session.chainId}`);
        }
        const sessionNonce = await getSessionNonce({
            client,
            account,
            permissionId,
        });
        const sessionDigest = await getSessionDigest({
            client,
            account,
            session,
            mode: enableMode || SmartSessionMode.ENABLE,
            permissionId,
        });
        chainDigests.push({
            chainId: session.chainId,
            sessionDigest,
        });
        chainSessions.push({
            chainId: session.chainId,
            session: {
                ...session,
                account: account.address,
                smartSession: SMART_SESSIONS_ADDRESS,
                mode: Number(enableMode) || Number(SmartSessionMode.ENABLE),
                nonce: sessionNonce,
            },
        });
    }
    const permissionEnableHash = hashChainSessions(chainSessions);
    const sessionToEnable = sessions[sessionIndex || 0];
    const permissionId = getPermissionId({
        session: sessionToEnable,
    });
    return {
        permissionEnableHash,
        mode: enableMode || SmartSessionMode.ENABLE,
        permissionId,
        signature: '0x',
        enableSessionData: {
            enableSession: {
                chainDigestIndex: sessionIndex || 0,
                hashesAndChainIds: chainDigests,
                sessionToEnable,
                permissionEnableSig: '0x',
            },
            validator: sessionToEnable.sessionValidator,
            accountType: account.type,
        },
    };
};
//# sourceMappingURL=usage.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnableSessionDetails = exports.getDisableActionPoliciesAction = exports.getEnableActionPoliciesAction = exports.getDisableERC1271PoliciesAction = exports.getEnableERC1271PoliciesAction = exports.getDisableUserOpPoliciesAction = exports.getEnableUserOpPoliciesAction = exports.getRemoveSessionAction = exports.getEnableSessionsAction = exports.formatPermissionEnableSig = exports.hashChainSessions = exports.decodeSmartSessionSignature = exports.encodeUseOrEnableSmartSessionSignature = exports.encodeSmartSessionSignature = exports.getSessionDigest = exports.isSessionEnabled = exports.getSessionNonce = exports.getActionId = exports.getPermissionId = void 0;
const viem_1 = require("viem");
const abi_1 = require("./abi");
const constants_1 = require("./constants");
const types_1 = require("./types");
const solady_1 = require("solady");
const getPermissionId = ({ session }) => {
    return (0, viem_1.keccak256)((0, viem_1.encodeAbiParameters)([
        {
            type: 'address',
            name: 'sessionValidator',
        },
        {
            type: 'bytes',
            name: 'sessionValidatorInitData',
        },
        {
            type: 'bytes32',
            name: 'salt',
        },
    ], [
        session.sessionValidator,
        session.sessionValidatorInitData,
        session.salt,
    ]));
};
exports.getPermissionId = getPermissionId;
const getActionId = async ({ target, selector, }) => {
    return (0, viem_1.keccak256)((0, viem_1.encodePacked)(['address', 'bytes4'], [target, selector]));
};
exports.getActionId = getActionId;
const getSessionNonce = async ({ client, account, permissionId, }) => {
    return (await client.readContract({
        address: constants_1.SMART_SESSIONS_ADDRESS,
        abi: abi_1.abi,
        functionName: 'getNonce',
        args: [permissionId, account.address],
    }));
};
exports.getSessionNonce = getSessionNonce;
const isSessionEnabled = async ({ client, account, permissionId, }) => {
    return (await client.readContract({
        address: constants_1.SMART_SESSIONS_ADDRESS,
        abi: abi_1.abi,
        functionName: 'isPermissionEnabled',
        args: [permissionId, account.address],
    }));
};
exports.isSessionEnabled = isSessionEnabled;
const getSessionDigest = async ({ client, account, session, permissionId, mode, }) => {
    return (await client.readContract({
        address: constants_1.SMART_SESSIONS_ADDRESS,
        abi: abi_1.abi,
        functionName: 'getSessionDigest',
        args: [permissionId, account.address, session, Number(mode)],
    }));
};
exports.getSessionDigest = getSessionDigest;
const encodeSmartSessionSignature = ({ mode, permissionId, signature, enableSessionData, }) => {
    switch (mode) {
        case types_1.SmartSessionMode.USE:
            return (0, viem_1.encodePacked)(['bytes1', 'bytes32', 'bytes'], [
                mode,
                permissionId,
                solady_1.LibZip.flzCompress((0, viem_1.encodeAbiParameters)([
                    {
                        type: 'bytes',
                    },
                ], [signature])),
            ]);
        case types_1.SmartSessionMode.ENABLE:
        case types_1.SmartSessionMode.UNSAFE_ENABLE:
            if (!enableSessionData) {
                throw new Error('enableSession is required for ENABLE mode');
            }
            return (0, viem_1.encodePacked)(['bytes1', 'bytes'], [
                mode,
                solady_1.LibZip.flzCompress(encodeEnableSessionSignature({ enableSessionData, signature })),
            ]);
        default:
            throw new Error(`Unknown mode ${mode}`);
    }
};
exports.encodeSmartSessionSignature = encodeSmartSessionSignature;
const encodeUseOrEnableSmartSessionSignature = async ({ account, client, permissionId, signature, enableSessionData, }) => {
    const sessionEnabled = await (0, exports.isSessionEnabled)({
        account,
        client,
        permissionId,
    });
    return sessionEnabled
        ? (0, viem_1.encodePacked)(['bytes1', 'bytes32', 'bytes'], [
            types_1.SmartSessionMode.USE,
            permissionId,
            solady_1.LibZip.flzCompress((0, viem_1.encodeAbiParameters)([
                {
                    type: 'bytes',
                },
            ], [signature])),
        ])
        : (0, viem_1.encodePacked)(['bytes1', 'bytes'], [
            types_1.SmartSessionMode.ENABLE,
            solady_1.LibZip.flzCompress(encodeEnableSessionSignature({ enableSessionData, signature })),
        ]);
};
exports.encodeUseOrEnableSmartSessionSignature = encodeUseOrEnableSmartSessionSignature;
const decodeSmartSessionSignature = ({ signature, account, }) => {
    const mode = (0, viem_1.slice)(signature, 0, 1);
    let permissionId;
    let compressedData;
    let data;
    switch (mode) {
        case types_1.SmartSessionMode.USE:
            permissionId = (0, viem_1.slice)(signature, 1, 33);
            compressedData = (0, viem_1.slice)(signature, 33);
            data = solady_1.LibZip.flzDecompress(compressedData);
            const decodedSignature = (0, viem_1.decodeAbiParameters)([
                {
                    type: 'bytes',
                },
            ], data)[0];
            return {
                mode,
                permissionId,
                signature: decodedSignature,
            };
        case types_1.SmartSessionMode.ENABLE:
        case types_1.SmartSessionMode.UNSAFE_ENABLE:
            compressedData = (0, viem_1.slice)(signature, 1);
            data = solady_1.LibZip.flzDecompress(compressedData);
            if (!account) {
                throw new Error('account is required for ENABLE mode decoding');
            }
            const decodedData = (0, viem_1.decodeAbiParameters)(abi_1.encodeEnableSessionSignatureAbi, data);
            const enableSession = decodedData[0];
            const permissionEnableSigSlice = account.type === 'kernel' ? 1 : 0;
            if (account.type === 'kernel' &&
                !enableSession.permissionEnableSig.startsWith('0x01')) {
                throw new Error('Invalid permissionEnableSig for kernel account');
            }
            const permissionEnableSig = (0, viem_1.slice)(enableSession.permissionEnableSig, 20 + permissionEnableSigSlice);
            const validator = (0, viem_1.slice)(enableSession.permissionEnableSig, 0 + permissionEnableSigSlice, 20 + permissionEnableSigSlice);
            return {
                mode: mode,
                permissionId: (0, viem_1.keccak256)((0, viem_1.encodeAbiParameters)([
                    {
                        type: 'address',
                        name: 'sessionValidator',
                    },
                    {
                        type: 'bytes',
                        name: 'sessionValidatorInitData',
                    },
                    {
                        type: 'bytes32',
                        name: 'salt',
                    },
                ], [
                    enableSession.sessionToEnable.sessionValidator,
                    enableSession.sessionToEnable.sessionValidatorInitData,
                    enableSession.sessionToEnable.salt,
                ])),
                signature: decodedData[1],
                enableSessionData: {
                    enableSession: {
                        chainDigestIndex: enableSession.chainDigestIndex,
                        hashesAndChainIds: enableSession.hashesAndChainIds,
                        sessionToEnable: enableSession.sessionToEnable,
                        permissionEnableSig: permissionEnableSig,
                    },
                    validator: validator,
                    accountType: account.type,
                },
            };
        default:
            throw new Error(`Unknown mode ${mode}`);
    }
};
exports.decodeSmartSessionSignature = decodeSmartSessionSignature;
const hashChainSessions = (chainSessions) => {
    return (0, viem_1.hashTypedData)({
        domain: {
            name: 'SmartSession',
            version: '1',
        },
        types: {
            PolicyData: [
                { name: 'policy', type: 'address' },
                { name: 'initData', type: 'bytes' },
            ],
            ActionData: [
                { name: 'actionTargetSelector', type: 'bytes4' },
                { name: 'actionTarget', type: 'address' },
                { name: 'actionPolicies', type: 'PolicyData[]' },
            ],
            ERC7739Data: [
                { name: 'allowedERC7739Content', type: 'string[]' },
                { name: 'erc1271Policies', type: 'PolicyData[]' },
            ],
            SessionEIP712: [
                { name: 'account', type: 'address' },
                { name: 'smartSession', type: 'address' },
                { name: 'mode', type: 'uint8' },
                { name: 'sessionValidator', type: 'address' },
                { name: 'salt', type: 'bytes32' },
                { name: 'sessionValidatorInitData', type: 'bytes' },
                { name: 'userOpPolicies', type: 'PolicyData[]' },
                { name: 'erc7739Policies', type: 'ERC7739Data' },
                { name: 'actions', type: 'ActionData[]' },
                { name: 'nonce', type: 'uint256' },
            ],
            ChainSessionEIP712: [
                { name: 'chainId', type: 'uint64' },
                { name: 'session', type: 'SessionEIP712' },
            ],
            MultiChainSessionEIP712: [
                { name: 'sessionsAndChainIds', type: 'ChainSessionEIP712[]' },
            ],
        },
        primaryType: 'MultiChainSessionEIP712',
        message: {
            sessionsAndChainIds: chainSessions,
        },
    });
};
exports.hashChainSessions = hashChainSessions;
const encodeEnableSessionSignature = ({ enableSessionData, signature, }) => {
    return (0, viem_1.encodeAbiParameters)(abi_1.encodeEnableSessionSignatureAbi, [
        {
            chainDigestIndex: enableSessionData.enableSession.chainDigestIndex,
            hashesAndChainIds: enableSessionData.enableSession.hashesAndChainIds,
            sessionToEnable: enableSessionData.enableSession.sessionToEnable,
            permissionEnableSig: (0, exports.formatPermissionEnableSig)({
                signature: enableSessionData.enableSession.permissionEnableSig,
                validator: enableSessionData.validator,
                accountType: enableSessionData.accountType,
            }),
        },
        signature,
    ]);
};
const formatPermissionEnableSig = ({ signature, validator, accountType, }) => {
    switch (accountType) {
        case 'erc7579-implementation':
        case 'nexus':
        case 'safe':
            return (0, viem_1.encodePacked)(['address', 'bytes'], [validator, signature]);
        case 'kernel':
            return (0, viem_1.encodePacked)(['bytes1', 'address', 'bytes'], ['0x01', validator, signature]);
        default:
            throw new Error(`Unsupported account type: ${accountType}`);
    }
};
exports.formatPermissionEnableSig = formatPermissionEnableSig;
const getEnableSessionsAction = ({ sessions, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'enableSessions',
        args: [sessions],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getEnableSessionsAction = getEnableSessionsAction;
const getRemoveSessionAction = ({ permissionId, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'removeSession',
        args: [permissionId],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getRemoveSessionAction = getRemoveSessionAction;
const getEnableUserOpPoliciesAction = ({ permissionId, userOpPolicies, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'enableUserOpPolicies',
        args: [permissionId, userOpPolicies],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getEnableUserOpPoliciesAction = getEnableUserOpPoliciesAction;
const getDisableUserOpPoliciesAction = ({ permissionId, userOpPolicies, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'disableUserOpPolicies',
        args: [permissionId, userOpPolicies],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getDisableUserOpPoliciesAction = getDisableUserOpPoliciesAction;
const getEnableERC1271PoliciesAction = ({ permissionId, erc1271Policies, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'enableERC1271Policies',
        args: [permissionId, erc1271Policies],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getEnableERC1271PoliciesAction = getEnableERC1271PoliciesAction;
const getDisableERC1271PoliciesAction = ({ permissionId, policies, contents, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'disableERC1271Policies',
        args: [permissionId, policies, contents],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getDisableERC1271PoliciesAction = getDisableERC1271PoliciesAction;
const getEnableActionPoliciesAction = ({ permissionId, actionPolicies, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'enableActionPolicies',
        args: [permissionId, actionPolicies],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getEnableActionPoliciesAction = getEnableActionPoliciesAction;
const getDisableActionPoliciesAction = ({ permissionId, actionId, policies, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        abi: abi_1.abi,
        functionName: 'disableActionPolicies',
        args: [permissionId, actionId, policies],
    });
    return {
        to: constants_1.SMART_SESSIONS_ADDRESS,
        target: constants_1.SMART_SESSIONS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getDisableActionPoliciesAction = getDisableActionPoliciesAction;
const getEnableSessionDetails = async ({ sessions, sessionIndex, enableMode, account, clients, }) => {
    const chainDigests = [];
    const chainSessions = [];
    for (const session of sessions) {
        const permissionId = (0, exports.getPermissionId)({
            session,
        });
        const client = clients.find((c) => BigInt(c.chain?.id ?? 0) === session.chainId);
        if (!client) {
            throw new Error(`Client not found for chainId ${session.chainId}`);
        }
        const sessionNonce = await (0, exports.getSessionNonce)({
            client,
            account,
            permissionId,
        });
        const sessionDigest = await (0, exports.getSessionDigest)({
            client,
            account,
            session,
            mode: enableMode || types_1.SmartSessionMode.ENABLE,
            permissionId,
        });
        chainDigests.push({
            chainId: session.chainId,
            sessionDigest,
        });
        chainSessions.push({
            chainId: session.chainId,
            session: {
                ...session,
                account: account.address,
                smartSession: constants_1.SMART_SESSIONS_ADDRESS,
                mode: Number(enableMode) || Number(types_1.SmartSessionMode.ENABLE),
                nonce: sessionNonce,
            },
        });
    }
    const permissionEnableHash = (0, exports.hashChainSessions)(chainSessions);
    const sessionToEnable = sessions[sessionIndex || 0];
    const permissionId = (0, exports.getPermissionId)({
        session: sessionToEnable,
    });
    return {
        permissionEnableHash,
        mode: enableMode || types_1.SmartSessionMode.ENABLE,
        permissionId,
        signature: '0x',
        enableSessionData: {
            enableSession: {
                chainDigestIndex: sessionIndex || 0,
                hashesAndChainIds: chainDigests,
                sessionToEnable,
                permissionEnableSig: '0x',
            },
            validator: sessionToEnable.sessionValidator,
            accountType: account.type,
        },
    };
};
exports.getEnableSessionDetails = getEnableSessionDetails;
//# sourceMappingURL=usage.js.map
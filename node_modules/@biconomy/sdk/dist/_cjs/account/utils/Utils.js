"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeMultiplier = exports.isTesting = exports.playgroundTrue = exports.getAccountDomainStructFields = exports.eip712WrapHash = exports.getAccountMeta = exports.wrapSignatureWith6492 = exports.addressEquals = exports.isValidRpcUrl = exports.isNullOrUndefined = void 0;
exports.packUserOp = packUserOp;
exports.percentage = percentage;
exports.convertToFactor = convertToFactor;
exports.makeInstallDataAndHash = makeInstallDataAndHash;
exports._hashTypedData = _hashTypedData;
exports.getTypesForEIP712Domain = getTypesForEIP712Domain;
exports.typeToString = typeToString;
exports.bigIntReplacer = bigIntReplacer;
exports.numberTo3Bytes = numberTo3Bytes;
exports.toHexString = toHexString;
const viem_1 = require("viem");
const Constants_1 = require("../../account/utils/Constants.js");
const abi_1 = require("../../constants/abi/index.js");
const Types_1 = require("../../modules/utils/Types.js");
function packUserOp(userOperation) {
    const hashedInitCode = (0, viem_1.keccak256)(userOperation.factory && userOperation.factoryData
        ? (0, viem_1.concat)([userOperation.factory, userOperation.factoryData])
        : "0x");
    const hashedCallData = (0, viem_1.keccak256)(userOperation.callData ?? "0x");
    const hashedPaymasterAndData = (0, viem_1.keccak256)(userOperation.paymaster
        ? (0, viem_1.concat)([
            userOperation.paymaster,
            (0, viem_1.pad)((0, viem_1.toHex)(userOperation.paymasterVerificationGasLimit || BigInt(0)), {
                size: 16
            }),
            (0, viem_1.pad)((0, viem_1.toHex)(userOperation.paymasterPostOpGasLimit || BigInt(0)), {
                size: 16
            }),
            userOperation.paymasterData || "0x"
        ])
        : "0x");
    return (0, viem_1.encodeAbiParameters)([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
    ], [
        userOperation.sender,
        userOperation.nonce ?? 0n,
        hashedInitCode,
        hashedCallData,
        (0, viem_1.concat)([
            (0, viem_1.pad)((0, viem_1.toHex)(userOperation.verificationGasLimit ?? 0n), {
                size: 16
            }),
            (0, viem_1.pad)((0, viem_1.toHex)(userOperation.callGasLimit ?? 0n), { size: 16 })
        ]),
        userOperation.preVerificationGas ?? 0n,
        (0, viem_1.concat)([
            (0, viem_1.pad)((0, viem_1.toHex)(userOperation.maxPriorityFeePerGas ?? 0n), {
                size: 16
            }),
            (0, viem_1.pad)((0, viem_1.toHex)(userOperation.maxFeePerGas ?? 0n), { size: 16 })
        ]),
        hashedPaymasterAndData
    ]);
}
const isNullOrUndefined = (value) => {
    return value === null || value === undefined;
};
exports.isNullOrUndefined = isNullOrUndefined;
const isValidRpcUrl = (url) => {
    const regex = /^(http:\/\/|wss:\/\/|https:\/\/).*/;
    return regex.test(url);
};
exports.isValidRpcUrl = isValidRpcUrl;
const addressEquals = (a, b) => !!a && !!b && a?.toLowerCase() === b.toLowerCase();
exports.addressEquals = addressEquals;
const wrapSignatureWith6492 = ({ factoryAddress, factoryCalldata, signature }) => {
    return (0, viem_1.concat)([
        (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)("address, bytes, bytes"), [
            factoryAddress,
            factoryCalldata,
            signature
        ]),
        "0x6492649264926492649264926492649264926492649264926492649264926492"
    ]);
};
exports.wrapSignatureWith6492 = wrapSignatureWith6492;
function percentage(partialValue, totalValue) {
    return (100 * partialValue) / totalValue;
}
function convertToFactor(percentage) {
    if (percentage) {
        if (percentage < 1 || percentage > 100) {
            throw new Error("The percentage value should be between 1 and 100.");
        }
        const factor = percentage / 100 + 1;
        return factor;
    }
    return 1;
}
function makeInstallDataAndHash(accountOwner, modules, domainName = Constants_1.NEXUS_DOMAIN_NAME, domainVersion = Constants_1.NEXUS_DOMAIN_VERSION) {
    const types = modules.map((module) => BigInt(Types_1.moduleTypeIds[module.type]));
    const initDatas = modules.map((module) => (0, viem_1.toHex)((0, viem_1.concat)([(0, viem_1.toBytes)(BigInt(Types_1.moduleTypeIds[module.type])), module.config])));
    const multiInstallData = (0, viem_1.encodeAbiParameters)([{ type: "uint256[]" }, { type: "bytes[]" }], [types, initDatas]);
    const structHash = (0, viem_1.keccak256)((0, viem_1.encodeAbiParameters)([{ type: "bytes32" }, { type: "address" }, { type: "bytes32" }], [
        Constants_1.MODULE_ENABLE_MODE_TYPE_HASH,
        Constants_1.MOCK_MULTI_MODULE_ADDRESS,
        (0, viem_1.keccak256)(multiInstallData)
    ]));
    const hashToSign = _hashTypedData(structHash, domainName, domainVersion, accountOwner);
    return [multiInstallData, hashToSign];
}
function _hashTypedData(structHash, name, version, verifyingContract) {
    const DOMAIN_SEPARATOR = (0, viem_1.keccak256)((0, viem_1.encodeAbiParameters)([
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "address" }
    ], [
        (0, viem_1.keccak256)((0, viem_1.stringToBytes)(Constants_1.NEXUS_DOMAIN_TYPEHASH)),
        (0, viem_1.keccak256)((0, viem_1.stringToBytes)(name)),
        (0, viem_1.keccak256)((0, viem_1.stringToBytes)(version)),
        verifyingContract
    ]));
    return (0, viem_1.keccak256)((0, viem_1.concat)([
        (0, viem_1.stringToBytes)("\x19\x01"),
        (0, viem_1.hexToBytes)(DOMAIN_SEPARATOR),
        (0, viem_1.hexToBytes)(structHash)
    ]));
}
function getTypesForEIP712Domain({ domain }) {
    return [
        typeof domain?.name === "string" && { name: "name", type: "string" },
        domain?.version && { name: "version", type: "string" },
        typeof domain?.chainId === "number" && {
            name: "chainId",
            type: "uint256"
        },
        domain?.verifyingContract && {
            name: "verifyingContract",
            type: "address"
        },
        domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean);
}
const getAccountMeta = async (client, accountAddress) => {
    try {
        const domain = await client.request({
            method: "eth_call",
            params: [
                {
                    to: accountAddress,
                    data: (0, viem_1.encodeFunctionData)({
                        abi: abi_1.EIP1271Abi,
                        functionName: "eip712Domain"
                    })
                },
                "latest"
            ]
        });
        if (domain !== "0x") {
            const decoded = (0, viem_1.decodeFunctionResult)({
                abi: [...abi_1.EIP1271Abi],
                functionName: "eip712Domain",
                data: domain
            });
            return {
                name: decoded?.[1],
                version: decoded?.[2],
                chainId: decoded?.[3]
            };
        }
    }
    catch (error) { }
    return {
        name: Constants_1.NEXUS_DOMAIN_NAME,
        version: Constants_1.NEXUS_DOMAIN_VERSION,
        chainId: client.chain
            ? BigInt(client.chain.id)
            : BigInt(await client.extend(viem_1.publicActions).getChainId())
    };
};
exports.getAccountMeta = getAccountMeta;
const eip712WrapHash = (typedHash, appDomainSeparator) => (0, viem_1.keccak256)((0, viem_1.concat)(["0x1901", appDomainSeparator, typedHash]));
exports.eip712WrapHash = eip712WrapHash;
function typeToString(typeDef) {
    return Object.entries(typeDef).map(([key, fields]) => {
        const fieldStrings = (fields ?? [])
            .map((field) => `${field.type} ${field.name}`)
            .join(",");
        return `${key}(${fieldStrings})`;
    });
}
function bigIntReplacer(_key, value) {
    return typeof value === "bigint" ? value.toString() : value;
}
function numberTo3Bytes(key) {
    const buffer = new Uint8Array(3);
    buffer[0] = Number((key >> 16n) & 0xffn);
    buffer[1] = Number((key >> 8n) & 0xffn);
    buffer[2] = Number(key & 0xffn);
    return buffer;
}
function toHexString(byteArray) {
    return Array.from(byteArray)
        .map((byte) => byte.toString(16).padStart(2, "0"))
        .join("");
}
const getAccountDomainStructFields = async (publicClient, accountAddress) => {
    const accountDomainStructFields = (await publicClient.readContract({
        address: accountAddress,
        abi: (0, viem_1.parseAbi)([
            "function eip712Domain() public view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions)"
        ]),
        functionName: "eip712Domain"
    }));
    const [fields, name, version, chainId, verifyingContract, salt, extensions] = accountDomainStructFields;
    const params = (0, viem_1.parseAbiParameters)([
        "bytes1, bytes32, bytes32, uint256, address, bytes32, bytes32"
    ]);
    return (0, viem_1.encodeAbiParameters)(params, [
        fields,
        (0, viem_1.keccak256)((0, viem_1.toBytes)(name)),
        (0, viem_1.keccak256)((0, viem_1.toBytes)(version)),
        chainId,
        verifyingContract,
        salt,
        (0, viem_1.keccak256)((0, viem_1.encodePacked)(["uint256[]"], [extensions]))
    ]);
};
exports.getAccountDomainStructFields = getAccountDomainStructFields;
exports.playgroundTrue = process?.env?.RUN_PLAYGROUND === "true";
exports.isTesting = process?.env?.TEST === "true";
const safeMultiplier = (bI, multiplier) => BigInt(Math.round(Number(bI) * multiplier));
exports.safeMultiplier = safeMultiplier;
//# sourceMappingURL=Utils.js.map
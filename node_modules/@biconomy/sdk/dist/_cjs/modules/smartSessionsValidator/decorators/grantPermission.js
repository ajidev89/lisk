"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionAction = void 0;
exports.grantPermission = grantPermission;
const account_abstraction_1 = require("viem/account-abstraction");
const utils_1 = require("viem/utils");
const account_1 = require("../../../account/index.js");
const AccountNotFound_1 = require("../../../account/utils/AccountNotFound.js");
const constants_1 = require("../../../constants/index.js");
const SmartSessionAbi_1 = require("../../../constants/abi/SmartSessionAbi.js");
const Helpers_1 = require("../Helpers.js");
const getPermissionAction = async ({ chainId, sessionRequestedInfo, client }) => {
    const sessions = [];
    const permissionIds = [];
    for (const sessionInfo of sessionRequestedInfo) {
        const actionPolicies = [];
        for (const actionPolicyInfo of sessionInfo.actionPoliciesInfo) {
            const actionConfig = (0, Helpers_1.createActionConfig)(actionPolicyInfo.rules ?? [], actionPolicyInfo.valueLimit);
            const uniActionPolicyData = (0, Helpers_1.toUniversalActionPolicy)(actionConfig);
            const timeFramePolicyData = (0, Helpers_1.toTimeRangePolicy)(actionPolicyInfo.validUntil ?? 0, actionPolicyInfo.validAfter ?? 0);
            const actionPolicy = (0, Helpers_1.createActionData)(actionPolicyInfo.contractAddress, actionPolicyInfo.functionSelector, [uniActionPolicyData, timeFramePolicyData]);
            actionPolicies.push(actionPolicy);
        }
        const userOpTimeFramePolicyData = (0, Helpers_1.toTimeRangePolicy)(sessionInfo.sessionValidUntil ?? 0, sessionInfo.sessionValidAfter ?? 0);
        const session = {
            chainId: BigInt(chainId),
            sessionValidator: sessionInfo.sessionValidatorAddress ?? constants_1.SIMPLE_SESSION_VALIDATOR_ADDRESS,
            sessionValidatorInitData: sessionInfo.sessionKeyData,
            salt: sessionInfo.salt ?? (0, Helpers_1.generateSalt)(),
            userOpPolicies: [userOpTimeFramePolicyData],
            actions: actionPolicies,
            erc7739Policies: {
                allowedERC7739Content: [],
                erc1271Policies: []
            }
        };
        const permissionId = (await (0, Helpers_1.getPermissionId)({
            client: client,
            session: session
        }));
        permissionIds.push(permissionId);
        sessions.push(session);
    }
    const grantPermissionData = (0, utils_1.encodeFunctionData)({
        abi: SmartSessionAbi_1.SmartSessionAbi,
        functionName: "enableSessions",
        args: [sessions]
    });
    return {
        action: {
            target: constants_1.SMART_SESSIONS_ADDRESS,
            value: BigInt(0),
            callData: grantPermissionData
        },
        permissionIds: permissionIds
    };
};
exports.getPermissionAction = getPermissionAction;
async function grantPermission(client, parameters) {
    const { publicClient: publicClient_ = client.account?.client, account: account_ = client.account, maxFeePerGas, maxPriorityFeePerGas, nonce, sessionRequestedInfo } = parameters;
    if (!account_) {
        throw new AccountNotFound_1.AccountNotFoundError({
            docsPath: "/nexus/nexus-client/methods#sendtransaction"
        });
    }
    const account = (0, utils_1.parseAccount)(account_);
    const chainId = publicClient_?.chain?.id;
    if (!chainId) {
        throw new Error(account_1.ERROR_MESSAGES.CHAIN_NOT_FOUND);
    }
    const defaultedSessionRequestedInfo = sessionRequestedInfo.map(Helpers_1.applyDefaults);
    const actionResponse = await (0, exports.getPermissionAction)({
        chainId,
        client: publicClient_,
        sessionRequestedInfo: defaultedSessionRequestedInfo
    });
    if ("action" in actionResponse) {
        const { action } = actionResponse;
        if (!("callData" in action)) {
            throw new Error("Error getting enable sessions action");
        }
        const userOpHash = (await (0, utils_1.getAction)(client, account_abstraction_1.sendUserOperation, "sendUserOperation")({
            calls: [
                {
                    to: action.target,
                    value: BigInt(action.value.toString()),
                    data: action.callData
                }
            ],
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            account
        }));
        return {
            userOpHash: userOpHash,
            permissionIds: actionResponse.permissionIds
        };
    }
    throw new Error("Error getting enable sessions action");
}
//# sourceMappingURL=grantPermission.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.policies = exports.toSpendingLimitsPolicy = exports.sudoPolicy = exports.toTimeRangePolicy = exports.toUniversalActionPolicy = exports.isPermissionEnabled = exports.getPermissionId = exports.toActionConfig = exports.createActionData = exports.applyDefaults = exports.createActionConfig = exports.generateSalt = exports.MAX_RULES = void 0;
exports.zipSessionData = zipSessionData;
exports.unzipSessionData = unzipSessionData;
const viem_1 = require("viem");
const constants_1 = require("../../constants/index.js");
const abi_1 = require("../../constants/abi/index.js");
const SmartSessionAbi_1 = require("../../constants/abi/SmartSessionAbi.js");
const Helpers_1 = require("../utils/Helpers.js");
exports.MAX_RULES = 16;
const generateSalt = () => {
    const randomBytes = new Uint8Array(32);
    crypto.getRandomValues(randomBytes);
    return `0x${Array.from(randomBytes, (byte) => byte.toString(16).padStart(2, "0")).join("")}`;
};
exports.generateSalt = generateSalt;
const createActionConfig = (rules, valueLimit = 0n) => ({
    paramRules: {
        length: rules.length,
        rules: rules
    },
    valueLimitPerUse: valueLimit
});
exports.createActionConfig = createActionConfig;
const applyDefaults = (sessionInfo) => {
    const sessionKeyData = sessionInfo.sessionKeyData ?? (0, viem_1.toHex)((0, viem_1.toBytes)(sessionInfo.sessionPublicKey));
    const sessionPublicKey = sessionInfo.sessionPublicKey ?? sessionKeyData;
    return {
        ...sessionInfo,
        sessionKeyData,
        sessionPublicKey,
        sessionValidUntil: sessionInfo.sessionValidUntil ?? 0,
        sessionValidAfter: sessionInfo.sessionValidAfter ?? 0,
        sessionValidatorAddress: sessionInfo.sessionValidatorAddress ?? constants_1.SIMPLE_SESSION_VALIDATOR_ADDRESS
    };
};
exports.applyDefaults = applyDefaults;
const createActionData = (contractAddress, functionSelector, policies) => {
    return {
        actionTarget: contractAddress,
        actionTargetSelector: (typeof functionSelector === "string"
            ? functionSelector
            : functionSelector.name),
        actionPolicies: policies
    };
};
exports.createActionData = createActionData;
const toActionConfig = (config) => {
    const filledRules = [...config.paramRules.rules];
    while (filledRules.length < exports.MAX_RULES) {
        filledRules.push({
            condition: 0,
            offsetIndex: 0,
            isLimited: false,
            ref: "0x0000000000000000000000000000000000000000000000000000000000000000",
            usage: {
                limit: BigInt(0),
                used: BigInt(0)
            }
        });
    }
    return {
        valueLimitPerUse: BigInt(config.valueLimitPerUse),
        paramRules: {
            length: config.paramRules.length,
            rules: filledRules.map((rule) => {
                const parsedRef = (0, Helpers_1.parseReferenceValue)(rule.ref);
                return {
                    condition: rule.condition,
                    offset: BigInt(rule.offsetIndex) * BigInt(32),
                    isLimited: rule.isLimited,
                    ref: parsedRef,
                    usage: rule.usage
                };
            })
        }
    };
};
exports.toActionConfig = toActionConfig;
const getPermissionId = async ({ client, session }) => {
    return (await client.readContract({
        address: constants_1.SMART_SESSIONS_ADDRESS,
        abi: SmartSessionAbi_1.SmartSessionAbi,
        functionName: "getPermissionId",
        args: [session]
    }));
};
exports.getPermissionId = getPermissionId;
const isPermissionEnabled = async ({ client, accountAddress, permissionId }) => client.readContract({
    address: constants_1.SMART_SESSIONS_ADDRESS,
    abi: SmartSessionAbi_1.SmartSessionAbi,
    functionName: "isPermissionEnabled",
    args: [permissionId, accountAddress]
});
exports.isPermissionEnabled = isPermissionEnabled;
const toUniversalActionPolicy = (actionConfig) => ({
    policy: constants_1.UNIVERSAL_ACTION_POLICY_ADDRESS,
    initData: (0, viem_1.encodeAbiParameters)(abi_1.UniActionPolicyAbi, [
        (0, exports.toActionConfig)(actionConfig)
    ])
});
exports.toUniversalActionPolicy = toUniversalActionPolicy;
const toTimeRangePolicy = (validUntil, validAfter) => {
    const validUntilBytes = (0, viem_1.pad)((0, viem_1.toBytes)(BigInt(validUntil), { size: 16 }), {
        dir: "right",
        size: 16
    });
    const validAfterBytes = (0, viem_1.pad)((0, viem_1.toBytes)(BigInt(validAfter), { size: 16 }), {
        dir: "right",
        size: 16
    });
    const packedData = (0, viem_1.encodePacked)(["bytes16", "bytes16"], [(0, viem_1.toHex)(validUntilBytes), (0, viem_1.toHex)(validAfterBytes)]);
    const timeFramePolicyData = {
        policy: constants_1.TIMEFRAME_POLICY_ADDRESS,
        initData: packedData
    };
    return timeFramePolicyData;
};
exports.toTimeRangePolicy = toTimeRangePolicy;
exports.sudoPolicy = {
    policy: "0x529Ad04F4D83aAb25144a90267D4a1443B84f5A6",
    initData: "0x"
};
const toSpendingLimitsPolicy = (params) => {
    return {
        policy: "0x8e58f4945e6ba2a11b184a9c20b6c765a0891b95",
        initData: (0, viem_1.encodeAbiParameters)([{ type: "address[]" }, { type: "uint256[]" }], [params.map(({ token }) => token), params.map(({ limit }) => limit)])
    };
};
exports.toSpendingLimitsPolicy = toSpendingLimitsPolicy;
exports.policies = {
    to: {
        universalAction: exports.toUniversalActionPolicy,
        spendingLimits: exports.toSpendingLimitsPolicy
    },
    sudo: exports.sudoPolicy
};
function zipSessionData(sessionData) {
    return JSON.stringify(sessionData);
}
function unzipSessionData(zippedData) {
    return JSON.parse(zippedData);
}
exports.default = exports.policies;
//# sourceMappingURL=Helpers.js.map